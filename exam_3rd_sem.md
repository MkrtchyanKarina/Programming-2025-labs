# ООП
## Билет 1. 
## Назовите основные принципы ООП. Дайте определение каждому из них. Объясните зачем каждый из принципов нужен.
Принципы ООП:
 	- инкапсуляция - принцип ограничения доступа к компонентам: классам, полям, методам. Нужен для их защиты от изменения.
 	- наследование - принцип создания нового класса, на основе существующего, во избежание повторения кода и создания иерархии, а также реализиции полиморфизма.
 	- полиморфизм - принцип выбора поведения в зависимости от типа объекта
 	- абстракция - принцип описания набора операций и свойств (контракта), и сокрытия внутренней реализации. Нужен для формирования общих методов для потомков, упрощения взаимодействия с классами и объектами
---
## Билет 2. 
## Чем класс отличается от объекта. Какие основные этапы жизни объекта вы можете выделить?
Класс - "чертеж", тип данных, содержащий набор
 	- свойств, полей, которые описывают состояние объекта;
 	- методов, которые описывают поведение объекта;
 	- конструкторов, интерфейсов, событий, которые обеспечивают взаимодействие с другими классами и объектами.
Объект  - экземпляр класса, конкретный "представитель", сущность, которая исполняет контракт, описанный классом.

## Билет 3.
## Дайте определение принципу ООП: наследование. Расскажите какие плюсы и минусы наследования вы знаете. Назовите любые 2 проблемы наследования и раскройте их.
Наследование - механизм, позволяющий одному классу перенимать свойства и методы другого класса, 
в результате абстрагирования общих методов и свойств создается новая сущность.
Плюсы: иерархия, повторное использование кода, полиморфизм, наследники специализируют поведение родителя
Минусы и проблемы: 
	Квадрат-прямоугольник - нарушение контракта - должна быть связь является (is-a), чтобы не нарушалась логика
	Банан-горилла-джунгли - избыточная сложность - много ненужных методов от базового класса
	Хрупкий базовый класс - хрупкость архитектуры - наследование должно быть от интерфейса, а не от самого класса
	Брильянтовая проблема - неодназначность -проблема множественного наследования (два класса переопределили метод, мы наследуемся от обоих, какая реализация в итоге?)

## Билет 4.
## Дайте определение принципу ООП: полиморфизм. Расскажите какие плюсы и минусы полиморфизма вы знаете. Назовите 4 разных вида полиморфизма и классифицируйте их.
Полиморфизм - способность объектов с разной внутренней структурой взаимодействовать по-разному, но иметь общий интерфейс. 
Виды полиморфизма:
	Статический - на этапе компиляции: пергрузка методов (ad-hoc), шаблоны/параметричсекий (generics - public void swap<T>(ref T a, ref T b))
	Динамический - на этапе выполнения: переопределение методов (virtual-override), приведения типов
Плюсы: Уменьшение связанности, повышение уровня абстракции, гибкость и расширяемость.
Минусы: Затраты на производительность, усложнение отладки, избыточность.

## Билет 5.
## Дайте определение принципам ООП: инкапсуляция и абстракция. Зачем нужна инкапсуляция, как реализована инкапсуляция в C++ подобных языках программирования
абстракция - описание набора операций и свойств (контракта), сокрытие внутренней реализации.

## Билет 6. 
## Что такое ассоциация, композиция, агрегация, в чем разница? Когда и что лучше из них использовать? 
Ассоциация - общая связь между объектами, которые могут существовать независимо друг от друга (преподаватель + студент)
Агрегация - слабая связь между объектами, один объект является частью другого, но может существовать без целого - has-a (группа + студент)
Композиция - сильная связь между объектами, один объект является частью другого и не может существовать без целого - has-a (авто + колеса)
Нужно выбирать вид связи, в зависимости от задачи, но лучше, чтобы все объекты зависели от абстракции (dependency inversion)

## Билет 7.
## Что такое интерфейс? Для чего его используют? Чем он отличается от абстрактного класса?
Интерфейс - это тип данных, содержащий методы без реализации, а также константы. В отличие от абстрактного класса не реализует методы, не содержит конструктора.
Класс может реализовывать несколько интерфейсов, а наследовать только один абстрактный класс.

## Билет 8.
## Что такое абстрактный класс? Зачем он нужен? Чем он отличается от интерфейса?
Абстрактный класс - это тип данных, который может содержать контейнер, а также реализованные и абстрактные методы.
Нужен для описания общей логики взаимосвязанных объектов. В отличие от интерфейса имеет контейнер и реализацию методов, но класс может наследоваться только от одного абстрактного класса.

## Билет 9.
## В чем разница статического и динамического полиморфизма, как они реализованы в C#? В каких языках программирования есть статический полиморфизм? В каких языках программирования есть динамический полиморфизм?
Статический полиморфизм выполняется еще на этапе компиляции (перевода всего кода на ЯП в машинный код), а динамический - во время выполнения программы. 
В C#: статический - шаблоны (generics), перегрузка методов (ad-hoc), динамический - переопределение методов (virtual-override), приведение типов.
Статический полиморфизм в виде перегрузки есть в Kotlin, Swift, Java, C++, Rust
Динамический полиморфизм через наследование есть в + Python, PHP, JavaScript 

## Билет 10.
## Что такое множественное наследование? Какие проблемы множественного наследования вы знаете? Как множественное наследование реализовано в C#?
Множественное наследование - наследование (создание дочернего класса) от нескольких родительских классов.
Брильянтовая проблема - непонятно, какую реализацию одного и того же метода использовать.
Множественное наследование в C# отсутствует, есть только множественная реализация интерфейсов.

## Билет 11.
## Что такое GRASP? Расскажите про Low Coupling High Cohesion, приведите пример системы где соблюдается и то и другое.
GRASP (General Responsibility Assignment Software Patterns) — это набор принципов и паттернов, которые помогают разработчикам принимать правильные решения при проектировании объектно-ориентированных систем. 
Помогают решить задачу с разделением ответственности между классами.
Low Coupling - низкая связанность - компоненты/классы в программе должны бать минимально связанны.
High Cohesion - высокая связанность - методы внутри класса должны быть тесно связаны, класс должен решать одну задачу.
Пример: способы оплаты в системе - взаимодействие через общий интерфейс, определение методов интерфейса + дополнительных в каждом отдельном классе для определенного вида оплаты.


## Билет 12. 
## Что такое SOLID? Расшифруйте каждую букву из Акронима. Для чего нужны эти принципы? Каковы основные преимущества их применения? 
SOLID - принципы проектирования системы, которые помогают сделать ее более гибкой, устойчивой к изменениям и масштабируемой.
S - single responsibility principle - принцип единственности ответственности - класс выполняет узкий круг задач, которые жестко с ним связаны.
O - Open-closed principle - принцип открытости и закрытости - классы должны быть закрыты для изменения и открыты для расширения.
L - Liskov substitution principle - принцип Барбары Лисков - вместо родительского класса можно подставить дочерний и работа системы не должна измениться
I - interface segregation principle - принцип разделения интерфейсов - интерфейсы должны бать разделены в зависимости от их задач.
D - dependency inversion principle - принцип инверсии зависимостей - модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракции.


## Билет 14.
## Принцип единственной ответственности (Single Responsibility Principle, SRP). Дайте определение, приведите пример ответственности класса. Как SRP связан с понятием "высокая связность" (high cohesion)?
Принцип единственной ответственности (SRP) гласит, что класс должен иметь одну и только одну причину для изменения, то есть отвечать за одну конкретную задачу или функциональность.
Пример: Класс Order не должен самостоятельно печатать чек или сохранять себя в базу. Его ответственность — управлять данными и логикой заказа. Печать чека и сохранение должны быть делегированы отдельным классам InvoicePrinter и OrderRepository.
Связь с высокой связностью (high cohesion): SRP напрямую ведёт к высокой связности. Если класс выполняет одну чёткую задачу, то все его методы и свойства тесно связаны общей целью, что и является высокой связностью. Выполняя SRP, мы автоматически повышаем связность модуля.

## Билет 15.
## Принцип открытости/закрытости (Open/Closed Principle, OCP). Сформулируйте принцип. Что означает "закрыт для …" и "открыт для …"? Какие паттерны проектирования чаще всего помогают следовать OCP? (Приведите 2-3 примера).
Классы должны быть открыты для расширения, но закрыты для модификации.
Связанные паттерны:
- Strategy: позволяет добавлять новые алгоритмы, не меняя клиентский код.
- Decorator: расширяет функциональность объектов динамически.

## Билет 16.
## Принцип подстановки Барбары Лисков (Liskov Substitution Principle, LSP). Дайте определение. Сформулируйте "инварианты", "постусловия" и "предусловия" в контексте LSP. Какие типичные последствия нарушения LSP для клиентского кода, использующего полиморфизм?
Классы-наследники должны быть способны заменить классы-родители, не нарушая работу клиентского кода. 
Инварианты — условия, истинные на протяжении всей жизни объекта (например, сумма счёта не отрицательна). 
Постусловия в наследнике не должны быть слабее, а предусловия — сильнее, чем у родителя. 
Нарушение LSP приводит к сбоям при полиморфном использовании: код, работающий с базовым классом, может выдать ошибку или некорректный результат при подстановке наследника.

## Билет 17.
## Принцип разделения интерфейсов (Interface Segregation Principle, ISP). В чем суть принципа? Что такое "толстый" интерфейс и каковы его недостатки? Как ISP способствует соблюдению принципа единственной ответственности (SRP) на уровне интерфейсов?
Клиенты не должны зависеть от методов, которые они не используют. 
«Толстый» интерфейс содержит множество разнородных методов, вынуждая реализации предоставлять пустые заглушки. 
ISP способствует SRP, декомпозируя такой интерфейс на несколько узкоспециализированных, каждый из которых соответствует одной ответственности.

## Билет 18.
## Принцип инверсии зависимостей (Dependency Inversion Principle, DIP). Сформулируйте два утверждения принципа. Объясните, что такое "модули верхнего уровня" и "низкого уровня". Какая разница между Dependency Inversion (принцип) и Dependency Injection (паттерн внедрения)?
Модули верхнего уровня (бизнес-логика) не должны зависеть от модулей нижнего уровня (детали реализации: БД, API). Оба должны зависеть от абстракций.
Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
Dependency Inversion — это принцип проектирования, а Dependency Injection — паттерн его реализации, заключающийся во внешнем предоставлении зависимостей объекту (через конструктор, свойства и т.д.).

## Билет 19.
## Объясните, как следование DIP и ISP повышает тестируемость кода (например, использование mock-объектов). Почему код, нарушающий SRP, часто сложнее тестировать?
DIP и ISP повышают тестируемость, позволяя внедрять mock-объекты через абстрактные интерфейсы вместо конкретных сложных зависимостей (БД, сетевых сервисов).
Нарушение SRP ведёт к «раздутым» классам со множеством обязанностей, что усложняет написание юнит-тестов — приходится подготавливать и проверять слишком много сценариев для одного теста.
